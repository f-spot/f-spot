// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace GLib {

	using System;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public class FileAdapter : GLib.GInterfaceAdapter, GLib.File {

		static FileIface iface;

		struct FileIface {
			public IntPtr gtype;
			public IntPtr itype;

			public DupDelegate dup;
			public HashDelegate hash;
			public EqualDelegate equal;
			public IsNativeDelegate is_native;
			public HasUriSchemeDelegate has_uri_scheme;
			public GetUriSchemeDelegate get_uri_scheme;
			public GetBasenameDelegate get_basename;
			public GetPathDelegate get_path;
			public IntPtr get_uri;
			public IntPtr get_parse_name;
			public GetParentDelegate get_parent;
			public IntPtr prefix_matches;
			public GetRelativePathDelegate get_relative_path;
			public ResolveRelativePathDelegate resolve_relative_path;
			public GetChildForDisplayNameDelegate get_child_for_display_name;
			public EnumerateChildrenDelegate enumerate_children;
			public EnumerateChildrenAsyncDelegate enumerate_children_async;
			public EnumerateChildrenFinishDelegate enumerate_children_finish;
			public QueryInfoDelegate query_info;
			public QueryInfoAsyncDelegate query_info_async;
			public QueryInfoFinishDelegate query_info_finish;
			public QueryFilesystemInfoDelegate query_filesystem_info;
			public QueryFilesystemInfoAsyncDelegate query_filesystem_info_async;
			public QueryFilesystemInfoFinishDelegate query_filesystem_info_finish;
			public FindEnclosingMountDelegate find_enclosing_mount;
			public FindEnclosingMountAsyncDelegate find_enclosing_mount_async;
			public FindEnclosingMountFinishDelegate find_enclosing_mount_finish;
			public SetDisplayNameDelegate set_display_name;
			public SetDisplayNameAsyncDelegate set_display_name_async;
			public SetDisplayNameFinishDelegate set_display_name_finish;
			public QuerySettableAttributesDelegate query_settable_attributes;
			public IntPtr _query_settable_attributes_async;
			public IntPtr _query_settable_attributes_finish;
			public QueryWritableNamespacesDelegate query_writable_namespaces;
			public IntPtr _query_writable_namespaces_async;
			public IntPtr _query_writable_namespaces_finish;
			public SetAttributeDelegate set_attribute;
			public SetAttributesFromInfoDelegate set_attributes_from_info;
			public SetAttributesAsyncDelegate set_attributes_async;
			public SetAttributesFinishDelegate set_attributes_finish;
			public IntPtr read_fn;
			public ReadAsyncDelegate read_async;
			public ReadFinishDelegate read_finish;
			public AppendToDelegate append_to;
			public AppendToAsyncDelegate append_to_async;
			public AppendToFinishDelegate append_to_finish;
			public CreateDelegate create;
			public CreateAsyncDelegate create_async;
			public CreateFinishDelegate create_finish;
			public ReplaceDelegate replace;
			public ReplaceAsyncDelegate replace_async;
			public ReplaceFinishDelegate replace_finish;
			public IntPtr delete_file;
			public IntPtr _delete_file_async;
			public IntPtr _delete_file_finish;
			public TrashDelegate trash;
			public IntPtr _trash_async;
			public IntPtr _trash_finish;
			public MakeDirectoryDelegate make_directory;
			public IntPtr _make_directory_async;
			public IntPtr _make_directory_finish;
			public MakeSymbolicLinkDelegate make_symbolic_link;
			public IntPtr _make_symbolic_link_async;
			public IntPtr _make_symbolic_link_finish;
			public CopyDelegate copy;
			public CopyAsyncDelegate copy_async;
			public CopyFinishDelegate copy_finish;
			public MoveDelegate move;
			public IntPtr _move_async;
			public IntPtr _move_finish;
			public MountMountableDelegate mount_mountable;
			public MountMountableFinishDelegate mount_mountable_finish;
			public UnmountMountableDelegate unmount_mountable;
			public UnmountMountableFinishDelegate unmount_mountable_finish;
			public EjectMountableDelegate eject_mountable;
			public EjectMountableFinishDelegate eject_mountable_finish;
			public MountEnclosingVolumeDelegate mount_enclosing_volume;
			public MountEnclosingVolumeFinishDelegate mount_enclosing_volume_finish;
			public IntPtr monitor_dir;
			public IntPtr monitor_file;
			public OpenReadwriteDelegate open_readwrite;
			public OpenReadwriteAsyncDelegate open_readwrite_async;
			public OpenReadwriteFinishDelegate open_readwrite_finish;
			public CreateReadwriteDelegate create_readwrite;
			public CreateReadwriteAsyncDelegate create_readwrite_async;
			public CreateReadwriteFinishDelegate create_readwrite_finish;
			public ReplaceReadwriteDelegate replace_readwrite;
			public ReplaceReadwriteAsyncDelegate replace_readwrite_async;
			public ReplaceReadwriteFinishDelegate replace_readwrite_finish;
			public StartMountableDelegate start_mountable;
			public StartMountableFinishDelegate start_mountable_finish;
			public StopMountableDelegate stop_mountable;
			public StopMountableFinishDelegate stop_mountable_finish;
			public UnmountMountableWithOperationDelegate unmount_mountable_with_operation;
			public UnmountMountableWithOperationFinishDelegate unmount_mountable_with_operation_finish;
			public EjectMountableWithOperationDelegate eject_mountable_with_operation;
			public EjectMountableWithOperationFinishDelegate eject_mountable_with_operation_finish;
			public PollMountableDelegate poll_mountable;
			public PollMountableFinishDelegate poll_mountable_finish;
		}

		static FileAdapter ()
		{
			GLib.GType.Register (_gtype, typeof(FileAdapter));
			iface.dup = new DupDelegate (DupCallback);
			iface.hash = new HashDelegate (HashCallback);
			iface.equal = new EqualDelegate (EqualCallback);
			iface.is_native = new IsNativeDelegate (IsNativeCallback);
			iface.has_uri_scheme = new HasUriSchemeDelegate (HasUriSchemeCallback);
			iface.get_uri_scheme = new GetUriSchemeDelegate (GetUriSchemeCallback);
			iface.get_basename = new GetBasenameDelegate (GetBasenameCallback);
			iface.get_path = new GetPathDelegate (GetPathCallback);
			iface.get_parent = new GetParentDelegate (GetParentCallback);
			iface.get_relative_path = new GetRelativePathDelegate (GetRelativePathCallback);
			iface.resolve_relative_path = new ResolveRelativePathDelegate (ResolveRelativePathCallback);
			iface.get_child_for_display_name = new GetChildForDisplayNameDelegate (GetChildForDisplayNameCallback);
			iface.enumerate_children = new EnumerateChildrenDelegate (EnumerateChildrenCallback);
			iface.enumerate_children_async = new EnumerateChildrenAsyncDelegate (EnumerateChildrenAsyncCallback);
			iface.enumerate_children_finish = new EnumerateChildrenFinishDelegate (EnumerateChildrenFinishCallback);
			iface.query_info = new QueryInfoDelegate (QueryInfoCallback);
			iface.query_info_async = new QueryInfoAsyncDelegate (QueryInfoAsyncCallback);
			iface.query_info_finish = new QueryInfoFinishDelegate (QueryInfoFinishCallback);
			iface.query_filesystem_info = new QueryFilesystemInfoDelegate (QueryFilesystemInfoCallback);
			iface.query_filesystem_info_async = new QueryFilesystemInfoAsyncDelegate (QueryFilesystemInfoAsyncCallback);
			iface.query_filesystem_info_finish = new QueryFilesystemInfoFinishDelegate (QueryFilesystemInfoFinishCallback);
			iface.find_enclosing_mount = new FindEnclosingMountDelegate (FindEnclosingMountCallback);
			iface.find_enclosing_mount_async = new FindEnclosingMountAsyncDelegate (FindEnclosingMountAsyncCallback);
			iface.find_enclosing_mount_finish = new FindEnclosingMountFinishDelegate (FindEnclosingMountFinishCallback);
			iface.set_display_name = new SetDisplayNameDelegate (SetDisplayNameCallback);
			iface.set_display_name_async = new SetDisplayNameAsyncDelegate (SetDisplayNameAsyncCallback);
			iface.set_display_name_finish = new SetDisplayNameFinishDelegate (SetDisplayNameFinishCallback);
			iface.query_settable_attributes = new QuerySettableAttributesDelegate (QuerySettableAttributesCallback);
			iface.query_writable_namespaces = new QueryWritableNamespacesDelegate (QueryWritableNamespacesCallback);
			iface.set_attribute = new SetAttributeDelegate (SetAttributeCallback);
			iface.set_attributes_from_info = new SetAttributesFromInfoDelegate (SetAttributesFromInfoCallback);
			iface.set_attributes_async = new SetAttributesAsyncDelegate (SetAttributesAsyncCallback);
			iface.set_attributes_finish = new SetAttributesFinishDelegate (SetAttributesFinishCallback);
			iface.read_async = new ReadAsyncDelegate (ReadAsyncCallback);
			iface.read_finish = new ReadFinishDelegate (ReadFinishCallback);
			iface.append_to = new AppendToDelegate (AppendToCallback);
			iface.append_to_async = new AppendToAsyncDelegate (AppendToAsyncCallback);
			iface.append_to_finish = new AppendToFinishDelegate (AppendToFinishCallback);
			iface.create = new CreateDelegate (CreateCallback);
			iface.create_async = new CreateAsyncDelegate (CreateAsyncCallback);
			iface.create_finish = new CreateFinishDelegate (CreateFinishCallback);
			iface.replace = new ReplaceDelegate (ReplaceCallback);
			iface.replace_async = new ReplaceAsyncDelegate (ReplaceAsyncCallback);
			iface.replace_finish = new ReplaceFinishDelegate (ReplaceFinishCallback);
			iface.trash = new TrashDelegate (TrashCallback);
			iface.make_directory = new MakeDirectoryDelegate (MakeDirectoryCallback);
			iface.make_symbolic_link = new MakeSymbolicLinkDelegate (MakeSymbolicLinkCallback);
			iface.copy = new CopyDelegate (CopyCallback);
			iface.copy_async = new CopyAsyncDelegate (CopyAsyncCallback);
			iface.copy_finish = new CopyFinishDelegate (CopyFinishCallback);
			iface.move = new MoveDelegate (MoveCallback);
			iface.mount_mountable = new MountMountableDelegate (MountMountableCallback);
			iface.mount_mountable_finish = new MountMountableFinishDelegate (MountMountableFinishCallback);
			iface.unmount_mountable = new UnmountMountableDelegate (UnmountMountableCallback);
			iface.unmount_mountable_finish = new UnmountMountableFinishDelegate (UnmountMountableFinishCallback);
			iface.eject_mountable = new EjectMountableDelegate (EjectMountableCallback);
			iface.eject_mountable_finish = new EjectMountableFinishDelegate (EjectMountableFinishCallback);
			iface.mount_enclosing_volume = new MountEnclosingVolumeDelegate (MountEnclosingVolumeCallback);
			iface.mount_enclosing_volume_finish = new MountEnclosingVolumeFinishDelegate (MountEnclosingVolumeFinishCallback);
			iface.open_readwrite = new OpenReadwriteDelegate (OpenReadwriteCallback);
			iface.open_readwrite_async = new OpenReadwriteAsyncDelegate (OpenReadwriteAsyncCallback);
			iface.open_readwrite_finish = new OpenReadwriteFinishDelegate (OpenReadwriteFinishCallback);
			iface.create_readwrite = new CreateReadwriteDelegate (CreateReadwriteCallback);
			iface.create_readwrite_async = new CreateReadwriteAsyncDelegate (CreateReadwriteAsyncCallback);
			iface.create_readwrite_finish = new CreateReadwriteFinishDelegate (CreateReadwriteFinishCallback);
			iface.replace_readwrite = new ReplaceReadwriteDelegate (ReplaceReadwriteCallback);
			iface.replace_readwrite_async = new ReplaceReadwriteAsyncDelegate (ReplaceReadwriteAsyncCallback);
			iface.replace_readwrite_finish = new ReplaceReadwriteFinishDelegate (ReplaceReadwriteFinishCallback);
			iface.start_mountable = new StartMountableDelegate (StartMountableCallback);
			iface.start_mountable_finish = new StartMountableFinishDelegate (StartMountableFinishCallback);
			iface.stop_mountable = new StopMountableDelegate (StopMountableCallback);
			iface.stop_mountable_finish = new StopMountableFinishDelegate (StopMountableFinishCallback);
			iface.unmount_mountable_with_operation = new UnmountMountableWithOperationDelegate (UnmountMountableWithOperationCallback);
			iface.unmount_mountable_with_operation_finish = new UnmountMountableWithOperationFinishDelegate (UnmountMountableWithOperationFinishCallback);
			iface.eject_mountable_with_operation = new EjectMountableWithOperationDelegate (EjectMountableWithOperationCallback);
			iface.eject_mountable_with_operation_finish = new EjectMountableWithOperationFinishDelegate (EjectMountableWithOperationFinishCallback);
			iface.poll_mountable = new PollMountableDelegate (PollMountableCallback);
			iface.poll_mountable_finish = new PollMountableFinishDelegate (PollMountableFinishCallback);
		}


		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr DupDelegate (IntPtr file);

		static IntPtr DupCallback (IntPtr file)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.File __result = __obj.Dup ();
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate uint HashDelegate (IntPtr file);

		static uint HashCallback (IntPtr file)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				uint __result = __obj.Hash ();
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool EqualDelegate (IntPtr file1, IntPtr file2);

		static bool EqualCallback (IntPtr file1, IntPtr file2)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file1, false) as GLib.FileImplementor;
				bool __result = __obj.Equal (GLib.FileAdapter.GetObject (file2, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool IsNativeDelegate (IntPtr file);

		static bool IsNativeCallback (IntPtr file)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.IsNative;
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool HasUriSchemeDelegate (IntPtr file, IntPtr uri_scheme);

		static bool HasUriSchemeCallback (IntPtr file, IntPtr uri_scheme)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.HasUriScheme (GLib.Marshaller.Utf8PtrToString (uri_scheme));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetUriSchemeDelegate (IntPtr file);

		static IntPtr GetUriSchemeCallback (IntPtr file)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				string __result = __obj.UriScheme;
				return GLib.Marshaller.StringToPtrGStrdup(__result);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetBasenameDelegate (IntPtr file);

		static IntPtr GetBasenameCallback (IntPtr file)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				string __result = __obj.Basename;
				return GLib.Marshaller.StringToPtrGStrdup(__result);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetPathDelegate (IntPtr file);

		static IntPtr GetPathCallback (IntPtr file)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				string __result = __obj.Path;
				return GLib.Marshaller.StringToPtrGStrdup(__result);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetParentDelegate (IntPtr file);

		static IntPtr GetParentCallback (IntPtr file)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.File __result = __obj.Parent;
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetRelativePathDelegate (IntPtr parent, IntPtr descendant);

		static IntPtr GetRelativePathCallback (IntPtr parent, IntPtr descendant)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (parent, false) as GLib.FileImplementor;
				string __result = __obj.GetRelativePath (GLib.FileAdapter.GetObject (descendant, false));
				return GLib.Marshaller.StringToPtrGStrdup(__result);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr ResolveRelativePathDelegate (IntPtr file, IntPtr relative_path);

		static IntPtr ResolveRelativePathCallback (IntPtr file, IntPtr relative_path)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.File __result = __obj.ResolveRelativePath (GLib.Marshaller.Utf8PtrToString (relative_path));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetChildForDisplayNameDelegate (IntPtr file, IntPtr display_name, out IntPtr error);

		static IntPtr GetChildForDisplayNameCallback (IntPtr file, IntPtr display_name, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.File __result = __obj.GetChildForDisplayName (GLib.Marshaller.Utf8PtrToString (display_name));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr EnumerateChildrenDelegate (IntPtr file, IntPtr attributes, int flags, IntPtr cancellable, out IntPtr error);

		static IntPtr EnumerateChildrenCallback (IntPtr file, IntPtr attributes, int flags, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileEnumerator __result = __obj.EnumerateChildren (GLib.Marshaller.Utf8PtrToString (attributes), (GLib.FileQueryInfoFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void EnumerateChildrenAsyncDelegate (IntPtr file, IntPtr attributes, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void EnumerateChildrenAsyncCallback (IntPtr file, IntPtr attributes, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.EnumerateChildrenAsync (GLib.Marshaller.Utf8PtrToString (attributes), (GLib.FileQueryInfoFlags) flags, io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr EnumerateChildrenFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr EnumerateChildrenFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileEnumerator __result = __obj.EnumerateChildrenFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr QueryInfoDelegate (IntPtr file, IntPtr attributes, int flags, IntPtr cancellable, out IntPtr error);

		static IntPtr QueryInfoCallback (IntPtr file, IntPtr attributes, int flags, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileInfo __result = __obj.QueryInfo (GLib.Marshaller.Utf8PtrToString (attributes), (GLib.FileQueryInfoFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void QueryInfoAsyncDelegate (IntPtr file, IntPtr attributes, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void QueryInfoAsyncCallback (IntPtr file, IntPtr attributes, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.QueryInfoAsync (GLib.Marshaller.Utf8PtrToString (attributes), (GLib.FileQueryInfoFlags) flags, io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr QueryInfoFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr QueryInfoFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileInfo __result = __obj.QueryInfoFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr QueryFilesystemInfoDelegate (IntPtr file, IntPtr attributes, IntPtr cancellable, out IntPtr error);

		static IntPtr QueryFilesystemInfoCallback (IntPtr file, IntPtr attributes, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileInfo __result = __obj.QueryFilesystemInfo (GLib.Marshaller.Utf8PtrToString (attributes), GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void QueryFilesystemInfoAsyncDelegate (IntPtr file, IntPtr attributes, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void QueryFilesystemInfoAsyncCallback (IntPtr file, IntPtr attributes, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.QueryFilesystemInfoAsync (GLib.Marshaller.Utf8PtrToString (attributes), io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr QueryFilesystemInfoFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr QueryFilesystemInfoFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileInfo __result = __obj.QueryFilesystemInfoFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr FindEnclosingMountDelegate (IntPtr file, IntPtr cancellable, out IntPtr error);

		static IntPtr FindEnclosingMountCallback (IntPtr file, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.Mount __result = __obj.FindEnclosingMount (GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void FindEnclosingMountAsyncDelegate (IntPtr file, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void FindEnclosingMountAsyncCallback (IntPtr file, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.FindEnclosingMountAsync (io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr FindEnclosingMountFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr FindEnclosingMountFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.Mount __result = __obj.FindEnclosingMountFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr SetDisplayNameDelegate (IntPtr file, IntPtr display_name, IntPtr cancellable, out IntPtr error);

		static IntPtr SetDisplayNameCallback (IntPtr file, IntPtr display_name, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.File __result = __obj.SetDisplayName (GLib.Marshaller.Utf8PtrToString (display_name), GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SetDisplayNameAsyncDelegate (IntPtr file, IntPtr display_name, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void SetDisplayNameAsyncCallback (IntPtr file, IntPtr display_name, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.SetDisplayNameAsync (GLib.Marshaller.Utf8PtrToString (display_name), io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr SetDisplayNameFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr SetDisplayNameFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.File __result = __obj.SetDisplayNameFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr QuerySettableAttributesDelegate (IntPtr file, IntPtr cancellable, out IntPtr error);

		static IntPtr QuerySettableAttributesCallback (IntPtr file, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileAttributeInfoList __result = __obj.QuerySettableAttributes (GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr QueryWritableNamespacesDelegate (IntPtr file, IntPtr cancellable, out IntPtr error);

		static IntPtr QueryWritableNamespacesCallback (IntPtr file, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileAttributeInfoList __result = __obj.QueryWritableNamespaces (GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SetAttributeDelegate (IntPtr file, IntPtr attribute, int type, IntPtr value_p, int flags, IntPtr cancellable, out IntPtr error);

		static bool SetAttributeCallback (IntPtr file, IntPtr attribute, int type, IntPtr value_p, int flags, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.SetAttribute (GLib.Marshaller.Utf8PtrToString (attribute), (GLib.FileAttributeType) type, value_p, (GLib.FileQueryInfoFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SetAttributesFromInfoDelegate (IntPtr file, IntPtr info, int flags, IntPtr cancellable, out IntPtr error);

		static bool SetAttributesFromInfoCallback (IntPtr file, IntPtr info, int flags, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.SetAttributesFromInfo (GLib.Object.GetObject(info) as GLib.FileInfo, (GLib.FileQueryInfoFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SetAttributesAsyncDelegate (IntPtr file, IntPtr info, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void SetAttributesAsyncCallback (IntPtr file, IntPtr info, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.SetAttributesAsync (GLib.Object.GetObject(info) as GLib.FileInfo, (GLib.FileQueryInfoFlags) flags, io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool SetAttributesFinishDelegate (IntPtr file, IntPtr result, IntPtr info, out IntPtr error);

		static bool SetAttributesFinishCallback (IntPtr file, IntPtr result, IntPtr info, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.SetAttributesFinish (GLib.AsyncResultAdapter.GetObject (result, false), GLib.Object.GetObject(info) as GLib.FileInfo);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ReadAsyncDelegate (IntPtr file, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void ReadAsyncCallback (IntPtr file, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.ReadAsync (io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr ReadFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr ReadFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileInputStream __result = __obj.ReadFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr AppendToDelegate (IntPtr file, int flags, IntPtr cancellable, out IntPtr error);

		static IntPtr AppendToCallback (IntPtr file, int flags, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileOutputStream __result = __obj.AppendTo ((GLib.FileCreateFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void AppendToAsyncDelegate (IntPtr file, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void AppendToAsyncCallback (IntPtr file, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.AppendToAsync ((GLib.FileCreateFlags) flags, io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr AppendToFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr AppendToFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileOutputStream __result = __obj.AppendToFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr CreateDelegate (IntPtr file, int flags, IntPtr cancellable, out IntPtr error);

		static IntPtr CreateCallback (IntPtr file, int flags, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileOutputStream __result = __obj.Create ((GLib.FileCreateFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CreateAsyncDelegate (IntPtr file, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void CreateAsyncCallback (IntPtr file, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.CreateAsync ((GLib.FileCreateFlags) flags, io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr CreateFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr CreateFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileOutputStream __result = __obj.CreateFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr ReplaceDelegate (IntPtr file, IntPtr etag, bool make_backup, int flags, IntPtr cancellable, out IntPtr error);

		static IntPtr ReplaceCallback (IntPtr file, IntPtr etag, bool make_backup, int flags, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileOutputStream __result = __obj.Replace (GLib.Marshaller.Utf8PtrToString (etag), make_backup, (GLib.FileCreateFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ReplaceAsyncDelegate (IntPtr file, IntPtr etag, bool make_backup, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void ReplaceAsyncCallback (IntPtr file, IntPtr etag, bool make_backup, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.ReplaceAsync (GLib.Marshaller.Utf8PtrToString (etag), make_backup, (GLib.FileCreateFlags) flags, io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr ReplaceFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr ReplaceFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileOutputStream __result = __obj.ReplaceFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool TrashDelegate (IntPtr file, IntPtr cancellable, out IntPtr error);

		static bool TrashCallback (IntPtr file, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.Trash (GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool MakeDirectoryDelegate (IntPtr file, IntPtr cancellable, out IntPtr error);

		static bool MakeDirectoryCallback (IntPtr file, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.MakeDirectory (GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool MakeSymbolicLinkDelegate (IntPtr file, IntPtr symlink_value, IntPtr cancellable, out IntPtr error);

		static bool MakeSymbolicLinkCallback (IntPtr file, IntPtr symlink_value, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.MakeSymbolicLink (GLib.Marshaller.Utf8PtrToString (symlink_value), GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool CopyDelegate (IntPtr source, IntPtr destination, int flags, IntPtr cancellable, GLibSharp.FileProgressCallbackNative progress_callback, IntPtr progress_callback_data, out IntPtr error);

		static bool CopyCallback (IntPtr source, IntPtr destination, int flags, IntPtr cancellable, GLibSharp.FileProgressCallbackNative progress_callback, IntPtr progress_callback_data, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (source, false) as GLib.FileImplementor;
				GLibSharp.FileProgressCallbackInvoker progress_callback_invoker = new GLibSharp.FileProgressCallbackInvoker (progress_callback, progress_callback_data);
				bool __result = __obj.Copy (GLib.FileAdapter.GetObject (destination, false), (GLib.FileCopyFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable, progress_callback_invoker.Handler);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CopyAsyncDelegate (IntPtr source, IntPtr destination, int flags, int io_priority, IntPtr cancellable, GLibSharp.FileProgressCallbackNative progress_callback, IntPtr progress_callback_data, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void CopyAsyncCallback (IntPtr source, IntPtr destination, int flags, int io_priority, IntPtr cancellable, GLibSharp.FileProgressCallbackNative progress_callback, IntPtr progress_callback_data, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (source, false) as GLib.FileImplementor;
				GLibSharp.FileProgressCallbackInvoker progress_callback_invoker = new GLibSharp.FileProgressCallbackInvoker (progress_callback, user_data);
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.CopyAsync (GLib.FileAdapter.GetObject (destination, false), (GLib.FileCopyFlags) flags, io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, progress_callback_invoker.Handler, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool CopyFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static bool CopyFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.CopyFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool MoveDelegate (IntPtr source, IntPtr destination, int flags, IntPtr cancellable, GLibSharp.FileProgressCallbackNative progress_callback, IntPtr progress_callback_data, out IntPtr error);

		static bool MoveCallback (IntPtr source, IntPtr destination, int flags, IntPtr cancellable, GLibSharp.FileProgressCallbackNative progress_callback, IntPtr progress_callback_data, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (source, false) as GLib.FileImplementor;
				GLibSharp.FileProgressCallbackInvoker progress_callback_invoker = new GLibSharp.FileProgressCallbackInvoker (progress_callback, progress_callback_data);
				bool __result = __obj.Move (GLib.FileAdapter.GetObject (destination, false), (GLib.FileCopyFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable, progress_callback_invoker.Handler);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MountMountableDelegate (IntPtr file, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void MountMountableCallback (IntPtr file, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.MountMountable ((GLib.MountMountFlags) flags, GLib.Object.GetObject(mount_operation) as GLib.MountOperation, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr MountMountableFinishDelegate (IntPtr file, IntPtr result, out IntPtr error);

		static IntPtr MountMountableFinishCallback (IntPtr file, IntPtr result, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.File __result = __obj.MountMountableFinish (GLib.AsyncResultAdapter.GetObject (result, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void UnmountMountableDelegate (IntPtr file, int flags, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void UnmountMountableCallback (IntPtr file, int flags, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.UnmountMountable ((GLib.MountUnmountFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool UnmountMountableFinishDelegate (IntPtr file, IntPtr result, out IntPtr error);

		static bool UnmountMountableFinishCallback (IntPtr file, IntPtr result, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.UnmountMountableFinish (GLib.AsyncResultAdapter.GetObject (result, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void EjectMountableDelegate (IntPtr file, int flags, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void EjectMountableCallback (IntPtr file, int flags, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.EjectMountable ((GLib.MountUnmountFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool EjectMountableFinishDelegate (IntPtr file, IntPtr result, out IntPtr error);

		static bool EjectMountableFinishCallback (IntPtr file, IntPtr result, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.EjectMountableFinish (GLib.AsyncResultAdapter.GetObject (result, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void MountEnclosingVolumeDelegate (IntPtr location, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void MountEnclosingVolumeCallback (IntPtr location, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (location, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.MountEnclosingVolume ((GLib.MountMountFlags) flags, GLib.Object.GetObject(mount_operation) as GLib.MountOperation, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool MountEnclosingVolumeFinishDelegate (IntPtr location, IntPtr result, out IntPtr error);

		static bool MountEnclosingVolumeFinishCallback (IntPtr location, IntPtr result, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (location, false) as GLib.FileImplementor;
				bool __result = __obj.MountEnclosingVolumeFinish (GLib.AsyncResultAdapter.GetObject (result, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr OpenReadwriteDelegate (IntPtr file, IntPtr cancellable, out IntPtr error);

		static IntPtr OpenReadwriteCallback (IntPtr file, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileIOStream __result = __obj.OpenReadwrite (GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void OpenReadwriteAsyncDelegate (IntPtr file, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void OpenReadwriteAsyncCallback (IntPtr file, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.OpenReadwriteAsync (io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr OpenReadwriteFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr OpenReadwriteFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileIOStream __result = __obj.OpenReadwriteFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr CreateReadwriteDelegate (IntPtr file, int flags, IntPtr cancellable, out IntPtr error);

		static IntPtr CreateReadwriteCallback (IntPtr file, int flags, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileIOStream __result = __obj.CreateReadwrite ((GLib.FileCreateFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void CreateReadwriteAsyncDelegate (IntPtr file, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void CreateReadwriteAsyncCallback (IntPtr file, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.CreateReadwriteAsync ((GLib.FileCreateFlags) flags, io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr CreateReadwriteFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr CreateReadwriteFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileIOStream __result = __obj.CreateReadwriteFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr ReplaceReadwriteDelegate (IntPtr file, IntPtr etag, bool make_backup, int flags, IntPtr cancellable, out IntPtr error);

		static IntPtr ReplaceReadwriteCallback (IntPtr file, IntPtr etag, bool make_backup, int flags, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileIOStream __result = __obj.ReplaceReadwrite (GLib.Marshaller.Utf8PtrToString (etag), make_backup, (GLib.FileCreateFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ReplaceReadwriteAsyncDelegate (IntPtr file, IntPtr etag, bool make_backup, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void ReplaceReadwriteAsyncCallback (IntPtr file, IntPtr etag, bool make_backup, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.ReplaceReadwriteAsync (GLib.Marshaller.Utf8PtrToString (etag), make_backup, (GLib.FileCreateFlags) flags, io_priority, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr ReplaceReadwriteFinishDelegate (IntPtr file, IntPtr res, out IntPtr error);

		static IntPtr ReplaceReadwriteFinishCallback (IntPtr file, IntPtr res, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLib.FileIOStream __result = __obj.ReplaceReadwriteFinish (GLib.AsyncResultAdapter.GetObject (res, false));
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void StartMountableDelegate (IntPtr file, int flags, IntPtr start_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void StartMountableCallback (IntPtr file, int flags, IntPtr start_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.StartMountable ((GLib.DriveStartFlags) flags, GLib.Object.GetObject(start_operation) as GLib.MountOperation, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool StartMountableFinishDelegate (IntPtr file, IntPtr result, out IntPtr error);

		static bool StartMountableFinishCallback (IntPtr file, IntPtr result, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.StartMountableFinish (GLib.AsyncResultAdapter.GetObject (result, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void StopMountableDelegate (IntPtr file, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void StopMountableCallback (IntPtr file, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.StopMountable ((GLib.MountUnmountFlags) flags, GLib.Object.GetObject(mount_operation) as GLib.MountOperation, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool StopMountableFinishDelegate (IntPtr file, IntPtr result, out IntPtr error);

		static bool StopMountableFinishCallback (IntPtr file, IntPtr result, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.StopMountableFinish (GLib.AsyncResultAdapter.GetObject (result, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void UnmountMountableWithOperationDelegate (IntPtr file, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void UnmountMountableWithOperationCallback (IntPtr file, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.UnmountMountableWithOperation ((GLib.MountUnmountFlags) flags, GLib.Object.GetObject(mount_operation) as GLib.MountOperation, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool UnmountMountableWithOperationFinishDelegate (IntPtr file, IntPtr result, out IntPtr error);

		static bool UnmountMountableWithOperationFinishCallback (IntPtr file, IntPtr result, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.UnmountMountableWithOperationFinish (GLib.AsyncResultAdapter.GetObject (result, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void EjectMountableWithOperationDelegate (IntPtr file, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void EjectMountableWithOperationCallback (IntPtr file, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.EjectMountableWithOperation ((GLib.MountUnmountFlags) flags, GLib.Object.GetObject(mount_operation) as GLib.MountOperation, GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool EjectMountableWithOperationFinishDelegate (IntPtr file, IntPtr result, out IntPtr error);

		static bool EjectMountableWithOperationFinishCallback (IntPtr file, IntPtr result, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.EjectMountableWithOperationFinish (GLib.AsyncResultAdapter.GetObject (result, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PollMountableDelegate (IntPtr file, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void PollMountableCallback (IntPtr file, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.PollMountable (GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool PollMountableFinishDelegate (IntPtr file, IntPtr result, out IntPtr error);

		static bool PollMountableFinishCallback (IntPtr file, IntPtr result, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				GLib.FileImplementor __obj = GLib.Object.GetObject (file, false) as GLib.FileImplementor;
				bool __result = __obj.PollMountableFinish (GLib.AsyncResultAdapter.GetObject (result, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}
		static void Initialize (IntPtr ifaceptr, IntPtr data)
		{
			FileIface native_iface = (FileIface) Marshal.PtrToStructure (ifaceptr, typeof (FileIface));
			native_iface.dup = iface.dup;
			native_iface.hash = iface.hash;
			native_iface.equal = iface.equal;
			native_iface.is_native = iface.is_native;
			native_iface.has_uri_scheme = iface.has_uri_scheme;
			native_iface.get_uri_scheme = iface.get_uri_scheme;
			native_iface.get_basename = iface.get_basename;
			native_iface.get_path = iface.get_path;
			native_iface.get_uri = iface.get_uri;
			native_iface.get_parse_name = iface.get_parse_name;
			native_iface.get_parent = iface.get_parent;
			native_iface.prefix_matches = iface.prefix_matches;
			native_iface.get_relative_path = iface.get_relative_path;
			native_iface.resolve_relative_path = iface.resolve_relative_path;
			native_iface.get_child_for_display_name = iface.get_child_for_display_name;
			native_iface.enumerate_children = iface.enumerate_children;
			native_iface.enumerate_children_async = iface.enumerate_children_async;
			native_iface.enumerate_children_finish = iface.enumerate_children_finish;
			native_iface.query_info = iface.query_info;
			native_iface.query_info_async = iface.query_info_async;
			native_iface.query_info_finish = iface.query_info_finish;
			native_iface.query_filesystem_info = iface.query_filesystem_info;
			native_iface.query_filesystem_info_async = iface.query_filesystem_info_async;
			native_iface.query_filesystem_info_finish = iface.query_filesystem_info_finish;
			native_iface.find_enclosing_mount = iface.find_enclosing_mount;
			native_iface.find_enclosing_mount_async = iface.find_enclosing_mount_async;
			native_iface.find_enclosing_mount_finish = iface.find_enclosing_mount_finish;
			native_iface.set_display_name = iface.set_display_name;
			native_iface.set_display_name_async = iface.set_display_name_async;
			native_iface.set_display_name_finish = iface.set_display_name_finish;
			native_iface.query_settable_attributes = iface.query_settable_attributes;
			native_iface._query_settable_attributes_async = iface._query_settable_attributes_async;
			native_iface._query_settable_attributes_finish = iface._query_settable_attributes_finish;
			native_iface.query_writable_namespaces = iface.query_writable_namespaces;
			native_iface._query_writable_namespaces_async = iface._query_writable_namespaces_async;
			native_iface._query_writable_namespaces_finish = iface._query_writable_namespaces_finish;
			native_iface.set_attribute = iface.set_attribute;
			native_iface.set_attributes_from_info = iface.set_attributes_from_info;
			native_iface.set_attributes_async = iface.set_attributes_async;
			native_iface.set_attributes_finish = iface.set_attributes_finish;
			native_iface.read_fn = iface.read_fn;
			native_iface.read_async = iface.read_async;
			native_iface.read_finish = iface.read_finish;
			native_iface.append_to = iface.append_to;
			native_iface.append_to_async = iface.append_to_async;
			native_iface.append_to_finish = iface.append_to_finish;
			native_iface.create = iface.create;
			native_iface.create_async = iface.create_async;
			native_iface.create_finish = iface.create_finish;
			native_iface.replace = iface.replace;
			native_iface.replace_async = iface.replace_async;
			native_iface.replace_finish = iface.replace_finish;
			native_iface.delete_file = iface.delete_file;
			native_iface._delete_file_async = iface._delete_file_async;
			native_iface._delete_file_finish = iface._delete_file_finish;
			native_iface.trash = iface.trash;
			native_iface._trash_async = iface._trash_async;
			native_iface._trash_finish = iface._trash_finish;
			native_iface.make_directory = iface.make_directory;
			native_iface._make_directory_async = iface._make_directory_async;
			native_iface._make_directory_finish = iface._make_directory_finish;
			native_iface.make_symbolic_link = iface.make_symbolic_link;
			native_iface._make_symbolic_link_async = iface._make_symbolic_link_async;
			native_iface._make_symbolic_link_finish = iface._make_symbolic_link_finish;
			native_iface.copy = iface.copy;
			native_iface.copy_async = iface.copy_async;
			native_iface.copy_finish = iface.copy_finish;
			native_iface.move = iface.move;
			native_iface._move_async = iface._move_async;
			native_iface._move_finish = iface._move_finish;
			native_iface.mount_mountable = iface.mount_mountable;
			native_iface.mount_mountable_finish = iface.mount_mountable_finish;
			native_iface.unmount_mountable = iface.unmount_mountable;
			native_iface.unmount_mountable_finish = iface.unmount_mountable_finish;
			native_iface.eject_mountable = iface.eject_mountable;
			native_iface.eject_mountable_finish = iface.eject_mountable_finish;
			native_iface.mount_enclosing_volume = iface.mount_enclosing_volume;
			native_iface.mount_enclosing_volume_finish = iface.mount_enclosing_volume_finish;
			native_iface.monitor_dir = iface.monitor_dir;
			native_iface.monitor_file = iface.monitor_file;
			native_iface.open_readwrite = iface.open_readwrite;
			native_iface.open_readwrite_async = iface.open_readwrite_async;
			native_iface.open_readwrite_finish = iface.open_readwrite_finish;
			native_iface.create_readwrite = iface.create_readwrite;
			native_iface.create_readwrite_async = iface.create_readwrite_async;
			native_iface.create_readwrite_finish = iface.create_readwrite_finish;
			native_iface.replace_readwrite = iface.replace_readwrite;
			native_iface.replace_readwrite_async = iface.replace_readwrite_async;
			native_iface.replace_readwrite_finish = iface.replace_readwrite_finish;
			native_iface.start_mountable = iface.start_mountable;
			native_iface.start_mountable_finish = iface.start_mountable_finish;
			native_iface.stop_mountable = iface.stop_mountable;
			native_iface.stop_mountable_finish = iface.stop_mountable_finish;
			native_iface.unmount_mountable_with_operation = iface.unmount_mountable_with_operation;
			native_iface.unmount_mountable_with_operation_finish = iface.unmount_mountable_with_operation_finish;
			native_iface.eject_mountable_with_operation = iface.eject_mountable_with_operation;
			native_iface.eject_mountable_with_operation_finish = iface.eject_mountable_with_operation_finish;
			native_iface.poll_mountable = iface.poll_mountable;
			native_iface.poll_mountable_finish = iface.poll_mountable_finish;
			Marshal.StructureToPtr (native_iface, ifaceptr, false);
			GCHandle gch = (GCHandle) data;
			gch.Free ();
		}

		public FileAdapter ()
		{
			InitHandler = new GLib.GInterfaceInitHandler (Initialize);
		}

		FileImplementor implementor;

		public FileAdapter (FileImplementor implementor)
		{
			if (implementor == null)
				throw new ArgumentNullException ("implementor");
			this.implementor = implementor;
		}

		public FileAdapter (IntPtr handle)
		{
			this.handle = handle;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_get_type();

		private static GLib.GType _gtype = new GLib.GType (g_file_get_type ());

		public override GLib.GType GType {
			get {
				return _gtype;
			}
		}

		IntPtr handle;
		public override IntPtr Handle {
			get {
				if (handle != IntPtr.Zero)
					return handle;
				return implementor == null ? IntPtr.Zero : implementor.Handle;
			}
		}

		public static File GetObject (IntPtr handle, bool owned)
		{
			GLib.Object obj = GLib.Object.GetObject (handle, owned);
			return GetObject (obj);
		}

		public static File GetObject (GLib.Object obj)
		{
			if (obj == null)
				return null;
			else if (obj is FileImplementor)
				return new FileAdapter (obj as FileImplementor);
			else if (obj as File == null)
				return new FileAdapter (obj.Handle);
			else
				return obj as File;
		}

		public FileImplementor Implementor {
			get {
				return implementor;
			}
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_copy(IntPtr raw, IntPtr destination, int flags, IntPtr cancellable, GLibSharp.FileProgressCallbackNative progress_callback, IntPtr progress_callback_data, out IntPtr error);

		public bool Copy(GLib.File destination, GLib.FileCopyFlags flags, GLib.Cancellable cancellable, GLib.FileProgressCallback progress_callback) {
			GLibSharp.FileProgressCallbackWrapper progress_callback_wrapper = new GLibSharp.FileProgressCallbackWrapper (progress_callback);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_copy(Handle, destination == null ? IntPtr.Zero : destination.Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, progress_callback_wrapper.NativeDelegate, IntPtr.Zero, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_get_basename(IntPtr raw);

		public string Basename { 
			get {
				IntPtr raw_ret = g_file_get_basename(Handle);
				string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
				return ret;
			}
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_create(IntPtr raw, int flags, IntPtr cancellable, out IntPtr error);

		public GLib.FileOutputStream Create(GLib.FileCreateFlags flags, GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_create(Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileOutputStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileOutputStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_eject_mountable_with_operation(IntPtr raw, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void EjectMountableWithOperation(GLib.MountUnmountFlags flags, GLib.MountOperation mount_operation, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_eject_mountable_with_operation(Handle, (int) flags, mount_operation == null ? IntPtr.Zero : mount_operation.Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_load_contents_async(IntPtr raw, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void LoadContentsAsync(GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_load_contents_async(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_open_readwrite_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.FileIOStream OpenReadwriteFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_open_readwrite_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.FileIOStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileIOStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_set_display_name(IntPtr raw, IntPtr display_name, IntPtr cancellable, out IntPtr error);

		public GLib.File SetDisplayName(string display_name, GLib.Cancellable cancellable) {
			IntPtr native_display_name = GLib.Marshaller.StringToPtrGStrdup (display_name);
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_set_display_name(Handle, native_display_name, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.File ret = GLib.FileAdapter.GetObject (raw_ret, false);
			GLib.Marshaller.Free (native_display_name);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_query_writable_namespaces(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public GLib.FileAttributeInfoList QueryWritableNamespaces(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_query_writable_namespaces(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileAttributeInfoList ret = raw_ret == IntPtr.Zero ? null : (GLib.FileAttributeInfoList) GLib.Opaque.GetOpaque (raw_ret, typeof (GLib.FileAttributeInfoList), false);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_load_partial_contents_async(IntPtr raw, IntPtr cancellable, GLibSharp.FileReadMoreCallbackNative read_more_callback, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void LoadPartialContentsAsync(GLib.Cancellable cancellable, GLib.FileReadMoreCallback read_more_callback, GLib.AsyncReadyCallback cb) {
			GLibSharp.FileReadMoreCallbackWrapper read_more_callback_wrapper = new GLibSharp.FileReadMoreCallbackWrapper (read_more_callback);
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_load_partial_contents_async(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, read_more_callback_wrapper.NativeDelegate, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_read_async(IntPtr raw, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void ReadAsync(int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_read_async(Handle, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_set_attributes_async(IntPtr raw, IntPtr info, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void SetAttributesAsync(GLib.FileInfo info, GLib.FileQueryInfoFlags flags, int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_set_attributes_async(Handle, info == null ? IntPtr.Zero : info.Handle, (int) flags, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_create_readwrite_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.FileIOStream CreateReadwriteFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_create_readwrite_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.FileIOStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileIOStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_eject_mountable_finish(IntPtr raw, IntPtr result, out IntPtr error);

		[Obsolete]
		public bool EjectMountableFinish(GLib.AsyncResult result) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_eject_mountable_finish(Handle, result == null ? IntPtr.Zero : result.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_query_default_handler(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public GLib.AppInfo QueryDefaultHandler(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_query_default_handler(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.AppInfo ret = GLib.AppInfoAdapter.GetObject (raw_ret, false);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_get_path(IntPtr raw);

		public string Path { 
			get {
				IntPtr raw_ret = g_file_get_path(Handle);
				string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
				return ret;
			}
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_equal(IntPtr raw, IntPtr file2);

		public bool Equal(GLib.File file2) {
			bool raw_ret = g_file_equal(Handle, file2 == null ? IntPtr.Zero : file2.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_set_attributes_from_info(IntPtr raw, IntPtr info, int flags, IntPtr cancellable, out IntPtr error);

		public bool SetAttributesFromInfo(GLib.FileInfo info, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_set_attributes_from_info(Handle, info == null ? IntPtr.Zero : info.Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_has_prefix(IntPtr raw, IntPtr prefix);

		public bool HasPrefix(GLib.File prefix) {
			bool raw_ret = g_file_has_prefix(Handle, prefix == null ? IntPtr.Zero : prefix.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_query_info_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.FileInfo QueryInfoFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_query_info_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.FileInfo ret = GLib.Object.GetObject(raw_ret) as GLib.FileInfo;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_set_display_name_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.File SetDisplayNameFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_set_display_name_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.File ret = GLib.FileAdapter.GetObject (raw_ret, false);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_make_directory(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public bool MakeDirectory(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_make_directory(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_append_to_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.FileOutputStream AppendToFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_append_to_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.FileOutputStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileOutputStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_load_contents(IntPtr raw, IntPtr cancellable, IntPtr contents, out UIntPtr length, IntPtr etag_out, out IntPtr error);

		public bool LoadContents(GLib.Cancellable cancellable, string contents, out ulong length, string etag_out) {
			UIntPtr native_length;
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_load_contents(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, GLib.Marshaller.StringToPtrGStrdup(contents), out native_length, GLib.Marshaller.StringToPtrGStrdup(etag_out), out error);
			bool ret = raw_ret;
			length = (ulong) native_length;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_get_parent(IntPtr raw);

		public GLib.File Parent { 
			get {
				IntPtr raw_ret = g_file_get_parent(Handle);
				GLib.File ret = GLib.FileAdapter.GetObject (raw_ret, false);
				return ret;
			}
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_eject_mountable(IntPtr raw, int flags, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		[Obsolete]
		public void EjectMountable(GLib.MountUnmountFlags flags, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_eject_mountable(Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_delete(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public bool Delete(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_delete(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern uint g_file_hash(IntPtr file);

		public static uint Hash(IntPtr file) {
			uint raw_ret = g_file_hash(file);
			uint ret = raw_ret;
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_append_to(IntPtr raw, int flags, IntPtr cancellable, out IntPtr error);

		public GLib.FileOutputStream AppendTo(GLib.FileCreateFlags flags, GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_append_to(Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileOutputStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileOutputStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern int g_file_query_file_type(IntPtr raw, int flags, IntPtr cancellable);

		public GLib.FileType QueryFileType(GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable) {
			int raw_ret = g_file_query_file_type(Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle);
			GLib.FileType ret = (GLib.FileType) raw_ret;
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_eject_mountable_with_operation_finish(IntPtr raw, IntPtr result, out IntPtr error);

		public bool EjectMountableWithOperationFinish(GLib.AsyncResult result) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_eject_mountable_with_operation_finish(Handle, result == null ? IntPtr.Zero : result.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_get_relative_path(IntPtr raw, IntPtr descendant);

		public string GetRelativePath(GLib.File descendant) {
			IntPtr raw_ret = g_file_get_relative_path(Handle, descendant == null ? IntPtr.Zero : descendant.Handle);
			string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_move(IntPtr raw, IntPtr destination, int flags, IntPtr cancellable, GLibSharp.FileProgressCallbackNative progress_callback, IntPtr progress_callback_data, out IntPtr error);

		public bool Move(GLib.File destination, GLib.FileCopyFlags flags, GLib.Cancellable cancellable, GLib.FileProgressCallback progress_callback) {
			GLibSharp.FileProgressCallbackWrapper progress_callback_wrapper = new GLibSharp.FileProgressCallbackWrapper (progress_callback);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_move(Handle, destination == null ? IntPtr.Zero : destination.Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, progress_callback_wrapper.NativeDelegate, IntPtr.Zero, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_enumerate_children(IntPtr raw, IntPtr attributes, int flags, IntPtr cancellable, out IntPtr error);

		public GLib.FileEnumerator EnumerateChildren(string attributes, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable) {
			IntPtr native_attributes = GLib.Marshaller.StringToPtrGStrdup (attributes);
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_enumerate_children(Handle, native_attributes, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileEnumerator ret = GLib.Object.GetObject(raw_ret) as GLib.FileEnumerator;
			GLib.Marshaller.Free (native_attributes);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_find_enclosing_mount_async(IntPtr raw, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void FindEnclosingMountAsync(int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_find_enclosing_mount_async(Handle, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_copy_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public bool CopyFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_copy_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_query_info(IntPtr raw, IntPtr attributes, int flags, IntPtr cancellable, out IntPtr error);

		public GLib.FileInfo QueryInfo(string attributes, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable) {
			IntPtr native_attributes = GLib.Marshaller.StringToPtrGStrdup (attributes);
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_query_info(Handle, native_attributes, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileInfo ret = GLib.Object.GetObject(raw_ret) as GLib.FileInfo;
			GLib.Marshaller.Free (native_attributes);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_poll_mountable_finish(IntPtr raw, IntPtr result, out IntPtr error);

		public bool PollMountableFinish(GLib.AsyncResult result) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_poll_mountable_finish(Handle, result == null ? IntPtr.Zero : result.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_set_display_name_async(IntPtr raw, IntPtr display_name, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void SetDisplayNameAsync(string display_name, int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			IntPtr native_display_name = GLib.Marshaller.StringToPtrGStrdup (display_name);
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_set_display_name_async(Handle, native_display_name, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
			GLib.Marshaller.Free (native_display_name);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_set_attribute_int64(IntPtr raw, IntPtr attribute, long value, int flags, IntPtr cancellable, out IntPtr error);

		public bool SetAttributeInt64(string attribute, long value, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable) {
			IntPtr native_attribute = GLib.Marshaller.StringToPtrGStrdup (attribute);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_set_attribute_int64(Handle, native_attribute, value, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_attribute);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_unmount_mountable_with_operation(IntPtr raw, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void UnmountMountableWithOperation(GLib.MountUnmountFlags flags, GLib.MountOperation mount_operation, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_unmount_mountable_with_operation(Handle, (int) flags, mount_operation == null ? IntPtr.Zero : mount_operation.Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_replace_readwrite_async(IntPtr raw, IntPtr etag, bool make_backup, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void ReplaceReadwriteAsync(string etag, bool make_backup, GLib.FileCreateFlags flags, int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			IntPtr native_etag = GLib.Marshaller.StringToPtrGStrdup (etag);
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_replace_readwrite_async(Handle, native_etag, make_backup, (int) flags, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
			GLib.Marshaller.Free (native_etag);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_get_child_for_display_name(IntPtr raw, IntPtr display_name, out IntPtr error);

		public GLib.File GetChildForDisplayName(string display_name) {
			IntPtr native_display_name = GLib.Marshaller.StringToPtrGStrdup (display_name);
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_get_child_for_display_name(Handle, native_display_name, out error);
			GLib.File ret = GLib.FileAdapter.GetObject (raw_ret, false);
			GLib.Marshaller.Free (native_display_name);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_replace_contents_async(IntPtr raw, IntPtr contents, UIntPtr length, IntPtr etag, bool make_backup, int flags, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void ReplaceContentsAsync(string contents, string etag, bool make_backup, GLib.FileCreateFlags flags, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			IntPtr native_contents = GLib.Marshaller.StringToPtrGStrdup (contents);
			IntPtr native_etag = GLib.Marshaller.StringToPtrGStrdup (etag);
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_replace_contents_async(Handle, native_contents, new UIntPtr ((ulong) System.Text.Encoding.UTF8.GetByteCount (contents)), native_etag, make_backup, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
			GLib.Marshaller.Free (native_contents);
			GLib.Marshaller.Free (native_etag);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_stop_mountable(IntPtr raw, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void StopMountable(GLib.MountUnmountFlags flags, GLib.MountOperation mount_operation, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_stop_mountable(Handle, (int) flags, mount_operation == null ? IntPtr.Zero : mount_operation.Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_stop_mountable_finish(IntPtr raw, IntPtr result, out IntPtr error);

		public bool StopMountableFinish(GLib.AsyncResult result) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_stop_mountable_finish(Handle, result == null ? IntPtr.Zero : result.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_create_async(IntPtr raw, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void CreateAsync(GLib.FileCreateFlags flags, int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_create_async(Handle, (int) flags, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_monitor(IntPtr raw, int flags, IntPtr cancellable, out IntPtr error);

		public GLib.FileMonitor Monitor(GLib.FileMonitorFlags flags, GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_monitor(Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileMonitor ret = GLib.Object.GetObject(raw_ret) as GLib.FileMonitor;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_query_info_async(IntPtr raw, IntPtr attributes, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void QueryInfoAsync(string attributes, GLib.FileQueryInfoFlags flags, int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			IntPtr native_attributes = GLib.Marshaller.StringToPtrGStrdup (attributes);
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_query_info_async(Handle, native_attributes, (int) flags, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
			GLib.Marshaller.Free (native_attributes);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_is_native(IntPtr raw);

		public bool IsNative { 
			get {
				bool raw_ret = g_file_is_native(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_query_exists(IntPtr raw, IntPtr cancellable);

		public bool QueryExists(GLib.Cancellable cancellable) {
			bool raw_ret = g_file_query_exists(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_create_readwrite_async(IntPtr raw, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void CreateReadwriteAsync(GLib.FileCreateFlags flags, int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_create_readwrite_async(Handle, (int) flags, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_set_attribute(IntPtr raw, IntPtr attribute, int type, IntPtr value_p, int flags, IntPtr cancellable, out IntPtr error);

		public bool SetAttribute(string attribute, GLib.FileAttributeType type, IntPtr value_p, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable) {
			IntPtr native_attribute = GLib.Marshaller.StringToPtrGStrdup (attribute);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_set_attribute(Handle, native_attribute, (int) type, value_p, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_attribute);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_unmount_mountable_with_operation_finish(IntPtr raw, IntPtr result, out IntPtr error);

		public bool UnmountMountableWithOperationFinish(GLib.AsyncResult result) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_unmount_mountable_with_operation_finish(Handle, result == null ? IntPtr.Zero : result.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_trash(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public bool Trash(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_trash(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_replace_readwrite_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.FileIOStream ReplaceReadwriteFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_replace_readwrite_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.FileIOStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileIOStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_get_child(IntPtr raw, IntPtr name);

		public GLib.File GetChild(string name) {
			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (name);
			IntPtr raw_ret = g_file_get_child(Handle, native_name);
			GLib.File ret = GLib.FileAdapter.GetObject (raw_ret, false);
			GLib.Marshaller.Free (native_name);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_load_partial_contents_finish(IntPtr raw, IntPtr res, IntPtr contents, out UIntPtr length, IntPtr etag_out, out IntPtr error);

		public bool LoadPartialContentsFinish(GLib.AsyncResult res, string contents, out ulong length, string etag_out) {
			UIntPtr native_length;
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_load_partial_contents_finish(Handle, res == null ? IntPtr.Zero : res.Handle, GLib.Marshaller.StringToPtrGStrdup(contents), out native_length, GLib.Marshaller.StringToPtrGStrdup(etag_out), out error);
			bool ret = raw_ret;
			length = (ulong) native_length;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_make_directory_with_parents(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public bool MakeDirectoryWithParents(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_make_directory_with_parents(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_dup(IntPtr raw);

		public GLib.File Dup() {
			IntPtr raw_ret = g_file_dup(Handle);
			GLib.File ret = GLib.FileAdapter.GetObject (raw_ret, false);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_create_readwrite(IntPtr raw, int flags, IntPtr cancellable, out IntPtr error);

		public GLib.FileIOStream CreateReadwrite(GLib.FileCreateFlags flags, GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_create_readwrite(Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileIOStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileIOStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_find_enclosing_mount_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.Mount FindEnclosingMountFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_find_enclosing_mount_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.Mount ret = GLib.MountAdapter.GetObject (raw_ret, false);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_read(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public GLib.FileInputStream Read(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_read(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileInputStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileInputStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_load_contents_finish(IntPtr raw, IntPtr res, IntPtr contents, out UIntPtr length, IntPtr etag_out, out IntPtr error);

		public bool LoadContentsFinish(GLib.AsyncResult res, string contents, out ulong length, string etag_out) {
			UIntPtr native_length;
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_load_contents_finish(Handle, res == null ? IntPtr.Zero : res.Handle, GLib.Marshaller.StringToPtrGStrdup(contents), out native_length, GLib.Marshaller.StringToPtrGStrdup(etag_out), out error);
			bool ret = raw_ret;
			length = (ulong) native_length;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_query_filesystem_info_async(IntPtr raw, IntPtr attributes, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void QueryFilesystemInfoAsync(string attributes, int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			IntPtr native_attributes = GLib.Marshaller.StringToPtrGStrdup (attributes);
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_query_filesystem_info_async(Handle, native_attributes, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
			GLib.Marshaller.Free (native_attributes);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_resolve_relative_path(IntPtr raw, IntPtr relative_path);

		public GLib.File ResolveRelativePath(string relative_path) {
			IntPtr native_relative_path = GLib.Marshaller.StringToPtrGStrdup (relative_path);
			IntPtr raw_ret = g_file_resolve_relative_path(Handle, native_relative_path);
			GLib.File ret = GLib.FileAdapter.GetObject (raw_ret, false);
			GLib.Marshaller.Free (native_relative_path);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_create_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.FileOutputStream CreateFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_create_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.FileOutputStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileOutputStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_mount_mountable(IntPtr raw, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void MountMountable(GLib.MountMountFlags flags, GLib.MountOperation mount_operation, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_mount_mountable(Handle, (int) flags, mount_operation == null ? IntPtr.Zero : mount_operation.Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_replace_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.FileOutputStream ReplaceFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_replace_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.FileOutputStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileOutputStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_mount_mountable_finish(IntPtr raw, IntPtr result, out IntPtr error);

		public GLib.File MountMountableFinish(GLib.AsyncResult result) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_mount_mountable_finish(Handle, result == null ? IntPtr.Zero : result.Handle, out error);
			GLib.File ret = GLib.FileAdapter.GetObject (raw_ret, false);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_poll_mountable(IntPtr raw, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void PollMountable(GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_poll_mountable(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_enumerate_children_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.FileEnumerator EnumerateChildrenFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_enumerate_children_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.FileEnumerator ret = GLib.Object.GetObject(raw_ret) as GLib.FileEnumerator;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_get_uri_scheme(IntPtr raw);

		public string UriScheme { 
			get {
				IntPtr raw_ret = g_file_get_uri_scheme(Handle);
				string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
				return ret;
			}
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_has_uri_scheme(IntPtr raw, IntPtr uri_scheme);

		public bool HasUriScheme(string uri_scheme) {
			IntPtr native_uri_scheme = GLib.Marshaller.StringToPtrGStrdup (uri_scheme);
			bool raw_ret = g_file_has_uri_scheme(Handle, native_uri_scheme);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_uri_scheme);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_query_filesystem_info_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.FileInfo QueryFilesystemInfoFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_query_filesystem_info_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.FileInfo ret = GLib.Object.GetObject(raw_ret) as GLib.FileInfo;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_start_mountable_finish(IntPtr raw, IntPtr result, out IntPtr error);

		public bool StartMountableFinish(GLib.AsyncResult result) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_start_mountable_finish(Handle, result == null ? IntPtr.Zero : result.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_get_parse_name(IntPtr raw);

		public string ParsedName { 
			get {
				IntPtr raw_ret = g_file_get_parse_name(Handle);
				string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
				return ret;
			}
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_open_readwrite(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public GLib.FileIOStream OpenReadwrite(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_open_readwrite(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileIOStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileIOStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_open_readwrite_async(IntPtr raw, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void OpenReadwriteAsync(int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_open_readwrite_async(Handle, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_supports_thread_contexts(IntPtr raw);

		public bool SupportsThreadContexts() {
			bool raw_ret = g_file_supports_thread_contexts(Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_unmount_mountable_finish(IntPtr raw, IntPtr result, out IntPtr error);

		[Obsolete]
		public bool UnmountMountableFinish(GLib.AsyncResult result) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_unmount_mountable_finish(Handle, result == null ? IntPtr.Zero : result.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_find_enclosing_mount(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public GLib.Mount FindEnclosingMount(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_find_enclosing_mount(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.Mount ret = GLib.MountAdapter.GetObject (raw_ret, false);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_replace_async(IntPtr raw, IntPtr etag, bool make_backup, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void ReplaceAsync(string etag, bool make_backup, GLib.FileCreateFlags flags, int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			IntPtr native_etag = GLib.Marshaller.StringToPtrGStrdup (etag);
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_replace_async(Handle, native_etag, make_backup, (int) flags, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
			GLib.Marshaller.Free (native_etag);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_start_mountable(IntPtr raw, int flags, IntPtr start_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void StartMountable(GLib.DriveStartFlags flags, GLib.MountOperation start_operation, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_start_mountable(Handle, (int) flags, start_operation == null ? IntPtr.Zero : start_operation.Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_copy_async(IntPtr raw, IntPtr destination, int flags, int io_priority, IntPtr cancellable, GLibSharp.FileProgressCallbackNative progress_callback, IntPtr progress_callback_data, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void CopyAsync(GLib.File destination, GLib.FileCopyFlags flags, int io_priority, GLib.Cancellable cancellable, GLib.FileProgressCallback progress_callback, GLib.AsyncReadyCallback cb) {
			GLibSharp.FileProgressCallbackWrapper progress_callback_wrapper = new GLibSharp.FileProgressCallbackWrapper (progress_callback);
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_copy_async(Handle, destination == null ? IntPtr.Zero : destination.Handle, (int) flags, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, progress_callback_wrapper.NativeDelegate, IntPtr.Zero, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_query_settable_attributes(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public GLib.FileAttributeInfoList QuerySettableAttributes(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_query_settable_attributes(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileAttributeInfoList ret = raw_ret == IntPtr.Zero ? null : (GLib.FileAttributeInfoList) GLib.Opaque.GetOpaque (raw_ret, typeof (GLib.FileAttributeInfoList), false);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_set_attributes_finish(IntPtr raw, IntPtr result, IntPtr info, out IntPtr error);

		public bool SetAttributesFinish(GLib.AsyncResult result, GLib.FileInfo info) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_set_attributes_finish(Handle, result == null ? IntPtr.Zero : result.Handle, info == null ? IntPtr.Zero : info.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_mount_enclosing_volume(IntPtr raw, int flags, IntPtr mount_operation, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void MountEnclosingVolume(GLib.MountMountFlags flags, GLib.MountOperation mount_operation, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_mount_enclosing_volume(Handle, (int) flags, mount_operation == null ? IntPtr.Zero : mount_operation.Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_replace_contents_finish(IntPtr raw, IntPtr res, IntPtr new_etag, out IntPtr error);

		public bool ReplaceContentsFinish(GLib.AsyncResult res, string new_etag) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_replace_contents_finish(Handle, res == null ? IntPtr.Zero : res.Handle, GLib.Marshaller.StringToPtrGStrdup(new_etag), out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_set_attribute_uint32(IntPtr raw, IntPtr attribute, uint value, int flags, IntPtr cancellable, out IntPtr error);

		public bool SetAttributeUint32(string attribute, uint value, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable) {
			IntPtr native_attribute = GLib.Marshaller.StringToPtrGStrdup (attribute);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_set_attribute_uint32(Handle, native_attribute, value, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_attribute);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_append_to_async(IntPtr raw, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void AppendToAsync(GLib.FileCreateFlags flags, int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_append_to_async(Handle, (int) flags, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_set_attribute_int32(IntPtr raw, IntPtr attribute, int value, int flags, IntPtr cancellable, out IntPtr error);

		public bool SetAttributeInt32(string attribute, int value, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable) {
			IntPtr native_attribute = GLib.Marshaller.StringToPtrGStrdup (attribute);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_set_attribute_int32(Handle, native_attribute, value, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_attribute);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_mount_enclosing_volume_finish(IntPtr raw, IntPtr result, out IntPtr error);

		public bool MountEnclosingVolumeFinish(GLib.AsyncResult result) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_mount_enclosing_volume_finish(Handle, result == null ? IntPtr.Zero : result.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_set_attribute_byte_string(IntPtr raw, IntPtr attribute, IntPtr value, int flags, IntPtr cancellable, out IntPtr error);

		public bool SetAttributeByteString(string attribute, string value, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable) {
			IntPtr native_attribute = GLib.Marshaller.StringToPtrGStrdup (attribute);
			IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_set_attribute_byte_string(Handle, native_attribute, native_value, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_attribute);
			GLib.Marshaller.Free (native_value);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_copy_attributes(IntPtr raw, IntPtr destination, int flags, IntPtr cancellable, out IntPtr error);

		public bool CopyAttributes(GLib.File destination, GLib.FileCopyFlags flags, GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_copy_attributes(Handle, destination == null ? IntPtr.Zero : destination.Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_set_attribute_string(IntPtr raw, IntPtr attribute, IntPtr value, int flags, IntPtr cancellable, out IntPtr error);

		public bool SetAttributeString(string attribute, string value, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable) {
			IntPtr native_attribute = GLib.Marshaller.StringToPtrGStrdup (attribute);
			IntPtr native_value = GLib.Marshaller.StringToPtrGStrdup (value);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_set_attribute_string(Handle, native_attribute, native_value, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_attribute);
			GLib.Marshaller.Free (native_value);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_replace(IntPtr raw, IntPtr etag, bool make_backup, int flags, IntPtr cancellable, out IntPtr error);

		public GLib.FileOutputStream Replace(string etag, bool make_backup, GLib.FileCreateFlags flags, GLib.Cancellable cancellable) {
			IntPtr native_etag = GLib.Marshaller.StringToPtrGStrdup (etag);
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_replace(Handle, native_etag, make_backup, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileOutputStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileOutputStream;
			GLib.Marshaller.Free (native_etag);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_enumerate_children_async(IntPtr raw, IntPtr attributes, int flags, int io_priority, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void EnumerateChildrenAsync(string attributes, GLib.FileQueryInfoFlags flags, int io_priority, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			IntPtr native_attributes = GLib.Marshaller.StringToPtrGStrdup (attributes);
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_enumerate_children_async(Handle, native_attributes, (int) flags, io_priority, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
			GLib.Marshaller.Free (native_attributes);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_set_attribute_uint64(IntPtr raw, IntPtr attribute, ulong value, int flags, IntPtr cancellable, out IntPtr error);

		public bool SetAttributeUint64(string attribute, ulong value, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable) {
			IntPtr native_attribute = GLib.Marshaller.StringToPtrGStrdup (attribute);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_set_attribute_uint64(Handle, native_attribute, value, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_attribute);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_make_symbolic_link(IntPtr raw, IntPtr symlink_value, IntPtr cancellable, out IntPtr error);

		public bool MakeSymbolicLink(string symlink_value, GLib.Cancellable cancellable) {
			IntPtr native_symlink_value = GLib.Marshaller.StringToPtrGStrdup (symlink_value);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_make_symbolic_link(Handle, native_symlink_value, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_symlink_value);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern bool g_file_replace_contents(IntPtr raw, IntPtr contents, UIntPtr length, IntPtr etag, bool make_backup, int flags, IntPtr new_etag, IntPtr cancellable, out IntPtr error);

		public bool ReplaceContents(string contents, string etag, bool make_backup, GLib.FileCreateFlags flags, string new_etag, GLib.Cancellable cancellable) {
			IntPtr native_contents = GLib.Marshaller.StringToPtrGStrdup (contents);
			IntPtr native_etag = GLib.Marshaller.StringToPtrGStrdup (etag);
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_file_replace_contents(Handle, native_contents, new UIntPtr ((ulong) System.Text.Encoding.UTF8.GetByteCount (contents)), native_etag, make_backup, (int) flags, GLib.Marshaller.StringToPtrGStrdup(new_etag), cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			GLib.Marshaller.Free (native_contents);
			GLib.Marshaller.Free (native_etag);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern void g_file_unmount_mountable(IntPtr raw, int flags, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		[Obsolete]
		public void UnmountMountable(GLib.MountUnmountFlags flags, GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_file_unmount_mountable(Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_query_filesystem_info(IntPtr raw, IntPtr attributes, IntPtr cancellable, out IntPtr error);

		public GLib.FileInfo QueryFilesystemInfo(string attributes, GLib.Cancellable cancellable) {
			IntPtr native_attributes = GLib.Marshaller.StringToPtrGStrdup (attributes);
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_query_filesystem_info(Handle, native_attributes, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileInfo ret = GLib.Object.GetObject(raw_ret) as GLib.FileInfo;
			GLib.Marshaller.Free (native_attributes);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_parse_name(IntPtr parse_name);

		public static GLib.File ParseName(string parse_name) {
			IntPtr native_parse_name = GLib.Marshaller.StringToPtrGStrdup (parse_name);
			IntPtr raw_ret = g_file_parse_name(native_parse_name);
			GLib.File ret = GLib.FileAdapter.GetObject (raw_ret, false);
			GLib.Marshaller.Free (native_parse_name);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_read_finish(IntPtr raw, IntPtr res, out IntPtr error);

		public GLib.FileInputStream ReadFinish(GLib.AsyncResult res) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_read_finish(Handle, res == null ? IntPtr.Zero : res.Handle, out error);
			GLib.FileInputStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileInputStream;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll")]
		static extern IntPtr g_file_replace_readwrite(IntPtr raw, IntPtr etag, bool make_backup, int flags, IntPtr cancellable, out IntPtr error);

		public GLib.FileIOStream ReplaceReadwrite(string etag, bool make_backup, GLib.FileCreateFlags flags, GLib.Cancellable cancellable) {
			IntPtr native_etag = GLib.Marshaller.StringToPtrGStrdup (etag);
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = g_file_replace_readwrite(Handle, native_etag, make_backup, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.FileIOStream ret = GLib.Object.GetObject(raw_ret) as GLib.FileIOStream;
			GLib.Marshaller.Free (native_etag);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

#endregion
#region Customized extensions
#line 1 "FileAdapter.custom"
// FileAdapter.custom - customizations to GLib.FileAdapter
//
// Author:
//   Stephane Delcroix  <stephane@delcroix.org>
//
// Copyright (C) 2008 Novell, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

public override string ToString ()
{
	return Uri.ToString ();
}

public bool Exists {
	get { return QueryExists (null); }
}

public bool Delete ()
{
	return Delete (null);
}

[DllImport("libgio-2.0-0.dll")]
static extern IntPtr g_file_get_uri(IntPtr raw);

public System.Uri Uri {
	get {
		IntPtr raw_ret = g_file_get_uri(Handle);
		string ret = GLib.Marshaller.PtrToStringGFree(raw_ret);
		return new System.Uri (ret);
	}
}

bool disposed = false;
public void Dispose ()
{
    if (!disposed) {
	    disposed = true;
	    var o = GLib.Object.GetObject (Handle, false);
	    if (o != null)
		    o.Dispose ();
    }
}

~FileAdapter ()
{
	if (!disposed)
		Dispose ();
}



#endregion
	}
}
